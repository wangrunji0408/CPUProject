ADDSP3 R0 0x0000
ADDSP3 R0 0x0000
NOP ;保存用户程序寄存器的地址 0xBF10-0xBF15 R0-R5  
B START
NOP
DELINT: NOP 			;中断处理程序
	NOP
	NOP
	SW_SP R0 0x0 ;保存R0,R1,R2
	SW_SP R1 0x1
	SW_SP R2 0x2
	SW_SP R3 0x3
	SW_SP R6 0x6
	SW_SP R7 0x7

	SW_SP R7 0x00
	LI R3 0x49		;提示终端，进入中断处理
	MFPC R7 
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 	;R6=0xBF00
	SW R6 R3 0x0000		;(R3='I'
	NOP
	MFPC R7 			;输出中断号
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	NOP
	LI R3 0x4E
	LI R6 0x00BF 
	SLL R6 R6 0x0000 	;R6=0xBF00 
	SW R6 R3 0x0000		;(R3='N'
	NOP
	LI R3 0x000F		;提示终端，中断处理结束
	MFPC R7 
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 	;R6=0xBF00 
	SW R6 R3 0x0000
	NOP
	LW_SP R0 0x0
	LW_SP R1 0x1
	LW_SP R2 0x2
	LW_SP R3 0x3
	LW_SP R6 0x6
	LW_SP R7 0x7		;r7=用户程序返回地址
	NOP
	MFIH R3				;用r3=IH（高位变成1）
	LI R0 0x0080
	SLL R0 R0 0x000
	OR R3 R0
	JR R6
	MTIH R3
START:	LI R0 0x07	;init  0x8251 ;初始化IH寄存器，最高位为1时，允许中断，为0时不允许。初始化为0，kernel不允许中断
	MTIH R0
	LI R0 0x00BF 		;初始化栈地址
	SLL R0 R0 0x0000
	ADDIU R0 0x10					;R0=0xBF10 
	MTSP R0
	NOP
	LI R6 0x00BF 		;用户寄存器值初始化
	SLL R6 R6 0x0000
	ADDIU R6 0x10					;R6=0xBF10 
	LI R0 0x0000
	SW R6 R0 0x0000
	SW R6 R0 0x0001
	SW R6 R0 0x0002
	SW R6 R0 0x0003
	SW R6 R0 0x0004
	SW R6 R0 0x0005
	MFPC R7 			;Send O 
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LI R0 0x004F
	SW R6 R0 0x0000
	NOP
	MFPC R7 			;Send K
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LI R0 0x004B
	SW R6 R0 0x0000
	NOP
	MFPC R7 			;Send \r
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LI R0 0x000A
	SW R6 R0 0x0000
	NOP
	MFPC R7 			;Send \n
	ADDIU R7 0x0003  
	NOP
	B TESTW 	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LI R0 0x000D
	SW R6 R0 0x0000
	NOP
BEGIN:	MFPC R7		;检测命令 ;接收字符，保存到r1
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R1 0x0000
	LI R6 0x00ff 
	AND R1 R6 
	NOP	
	LI R0 0x0052		;检测是否为R命令
	CMP R0 R1
	BTEQZ SHOWREGS	
	NOP	
	LI R0 0x0044		;检测是否为D命令
	CMP R0 R1
	BTEQZ SHOWMEM
	NOP	
	LI R0 0x0041		;检测是否为A命令
	CMP R0 R1
	BTEQZ GOTOASM
	NOP	
	LI R0 0x0055		;检测是否为U命令
	CMP R0 R1
	BTEQZ GOTOUASM
	NOP	
	LI R0 0x0047		;检测是否为G命令
	CMP R0 R1
	BTEQZ GOTOCOMPILE
	NOP		
	B BEGIN
	NOP
GOTOUASM:	NOP			;各处理块的入口
	B UASM
	NOP
GOTOASM:	NOP
	B ASM
	NOP
GOTOCOMPILE:	NOP
	B COMPILE
	NOP
TESTW:	NOP	 			;测试8251是否能写
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	ADDIU R6 0x0001 
	LW R6 R0 0x0000 
	LI R6 0x0001 
	AND R0 R6 
	BEQZ R0 TESTW     ;BF01&1=0 则等待	
	NOP		
	JR R7
	NOP 
TESTR:	NOP				;测试8251是否能读
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	ADDIU R6 0x0001 
	LW R6 R0 0x0000 
	LI R6 0x0002
	AND R0 R6 
	BEQZ R0 TESTR   ;BF01&2=0  则等待	
	NOP	
	JR R7
	NOP 		
SHOWREGS:    LI R1 0x0006   ;R1递减  ;R命令，打印R0-R5
	LI R2 0x0006   ;R2不变
LOOP:	LI R0  0x00BF
	SLL R0 R0 0x0000
	ADDIU R0 0x0010
	SUBU R2 R1 R3   ;R2=0,1,2,3
	ADDU R0 R3 R0   ;R0=BF10...
	LW R0 R3 0x0000    ;R3=用户程序的 R0,R1,R2	
	MFPC R7				;发送低八位
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=BF00	
	SW R6 R3 0x0000	
	SRA R3 R3 0x0000	;发送高八位
	MFPC R7
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00	
	SW R6 R3 0x0000	
	ADDIU R1 0xFFFF
	NOP
	BNEZ R1 LOOP
	NOP	
	B BEGIN
	NOP
SHOWMEM:  MFPC R7	;查看内存	;D读取地址低位到r5
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000	
	LI R6 0x00FF
	AND R5 R6
	NOP	
	MFPC R7			;读取地址高位到r1
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R1 0x0000
	LI R6 0x00FF
	AND R1 R6
	NOP	
	SLL R1 R1 0x0000	;R1存储地址
	OR R1 R5
	MFPC R7				;读取显示次数低位到R5
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000
	LI R6 0x00FF
	AND R5 R6
	NOP	
	MFPC R7				;读取显示次数高位到R2
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R2 0x0000
	LI R6 0x00FF
	AND R2 R6
	NOP	
	SLL R2 R2 0x0000	;R2保存内存个数
	OR R2 R5
MEMLOOP:	LW R1 R3 0x0000    ;循环发出	;R3为内存数据	0x0130
	MFPC R7				;发送低八位
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00	
	SW R6 R3 0x0000	
	SRA R3 R3 0x0000	;发送高八位
	MFPC R7
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00	
	SW R6 R3 0x0000	
	ADDIU R1 0x0001   ;R1=地址加加加
	ADDIU R2 0xFFFF
	NOP
	BNEZ R2 MEMLOOP
	NOP	
	B BEGIN
	NOP		
ASM:  MFPC R7		 ;汇编	;A命令读取地址低位到r5
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000
	LI R6 0x00FF
	AND R5 R6
	NOP	
	MFPC R7			;读取地址高位到r1
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R1 0x0000
	LI R6 0x00FF
	AND R1 R6
	NOP	
	SLL R1 R1 0x0000	;R1存储地址
	OR R1 R5
	LI R0 0x0000		;检测地址是否合法
	CMP R0 R1      
	BTEQZ GOTOBEGIN
	NOP	
	MFPC R7				;读取数据低位到R5
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000
	LI R6 0x00FF
	AND R5 R6
	NOP	
	MFPC R7				;读取数据高位到R2
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R2 0x0000
	LI R6 0x00FF
	AND R2 R6
	NOP	
	SLL R2 R2 0x0000	;R2保存数据
	OR R2 R5
	SW R1 R2 0x0000	
	NOP
	B ASM
	NOP
GOTOBEGIN:	NOP
	B BEGIN
	NOP
UASM:	MFPC R7		;反汇编：将需要反汇编的地址处的值发给终端处理	 ;读取地址低位到r5
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000
	LI R6 0x00FF
	AND R5 R6
	NOP	
	MFPC R7				;读取地址高位到r1
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R1 0x0000
	LI R6 0x00FF
	AND R1 R6
	NOP	
	SLL R1 R1 0x0000	;R1存储地址
	OR R1 R5
	MFPC R7				;读取显示次数低位到R5
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000
	LI R6 0x00FF
	AND R5 R6
	NOP	
	MFPC R7				;读取显示次数高位到R2
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R2 0x0000
	LI R6 0x00FF
	AND R2 R6
	NOP	
	SLL R2 R2 0x0000	;R2保存内存个数
	OR R2 R5
UASMLOOP:	LW R1 R3 0x0000    ;循环发出	;R3为内存数据	
	MFPC R7				;发送低八位
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00	
	SW R6 R3 0x0000	
	SRA R3 R3 0x0000	;发送高八位
	MFPC R7
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00	
	SW R6 R3 0x0000	
	ADDIU R1 0x0001   ;R1=地址加加加
	ADDIU R2 0xFFFF
	NOP
	BNEZ R2 UASMLOOP
	NOP	
	B BEGIN
	NOP			
COMPILE:	MFPC R7		;连续执行 ;读取地址低位到R5
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R5 0x0000
	LI R6 0x00FF
	AND R5 R6
	NOP	
	MFPC R7				;读取内存高位到R2
	ADDIU R7 0x0003	
	NOP	
	B TESTR	
	NOP
	LI R6 0x00BF 
	SLL R6 R6 0x0000 
	LW R6 R2 0x0000
	LI R6 0x00FF
	AND R2 R6
	NOP	
	SLL R2 R2 0x0000	;R2保存内存地址  传给r6
	OR R2 R5
	ADDIU3 R2 R6 0x0000
	LI R7 0x00BF		;
	SLL R7 R7 0x0000
	ADDIU R7 0x0010
	LW R7 R5 0x0005		;
	ADDSP 0xFFFF
	SW_SP R5 0x0000
	MFIH R5				;中断保存在R5中
	LI R1 0x0080
	SLL R1 R1 0x000
	OR R5 R1
	LW R7 R0 0x0000		;恢复现场
	LW R7 R1 0x0001
	LW R7 R2 0x0002
	LW R7 R3 0x0003
	LW R7 R4 0x0004
	MFPC R7
	ADDIU R7 0x0004
	MTIH R5    ;IH高位赋1	
	JR R6
	LW_SP R5 0x0000  ;R5恢复现场
	NOP					;用户程序执行完毕，返回kernel，保存现场
	NOP
	ADDSP 0x0001
	LI R7 0x00BF
	SLL R7 R7 0x0000
	ADDIU R7 0x0010
	SW R7 R0 0x0000		;
	SW R7 R1 0x0001
	SW R7 R2 0x0002
	SW R7 R3 0x0003
	SW R7 R4 0x0004
	SW R7 R5 0x0005
	MFIH R0				;IH高位赋0
	LI R1 0x007F
	SLL R1 R1 0x0000
	LI R2 0x00FF
	OR R1 R2	
	AND R0 R1
	MTIH R0
	LI R1 0x0007		;给终端发送结束用户程序提示
	MFPC R7
	ADDIU R7 0x0003	
	NOP
	B TESTW	
	NOP	
	LI R6 0x00BF 
	SLL R6 R6 0x0000 ;R6=0xBF00	
	SW R6 R1 0x0000		
	B BEGIN
	NOP	
